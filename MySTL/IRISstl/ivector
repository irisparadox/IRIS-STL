#ifndef _IVECTOR_
#define _IVECTOR
#include <imacros>
#include <iexceptions>

_IRIS_BEGIN
template <class _iTy>
class _iVector_const_iterator {
public:
	using value_type	  = _iTy;
	using const_pointer   = const _iTy*;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;
	using offset_type	  = ioffset_t;

	inline _iVector_const_iterator() noexcept : _Ptr(), _Idx(0) {}
	inline explicit _iVector_const_iterator(const_pointer _Pvec, size_type _Off = 0) noexcept : _Ptr(_Pvec), _Idx(_Off) {}

public:
	inline const_reference operator*() const noexcept {
		return *operator->();
	}

	inline const_reference operator->() const noexcept {
		return _Ptr + _Idx;
	}

private:
	const_pointer _Ptr;
	size_type _Idx;
};

template <class _iTy>
class vector_container {
public:
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference		  = _iTy&;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;

	inline vector_container() noexcept : _First(), _Last(), _End() {}

	inline vector_container(pointer _first, pointer _last, pointer _end) : _First(_first), _Last(_last), _End(_end) {}

	pointer _First;
	pointer _Last;
	pointer _End;
};

template <class _iTy>
class ivector {
public:
	using value_type	  = _iTy;
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference       = _iTy&;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;

	using const_iterator = _iVector_const_iterator;

	inline ivector() : _Elems() {}

	inline ~ivector() {
		_Dealloc();
	}

public:
	inline const_iterator cbegin() noexcept {
		return const_iterator(_Elems._First, 0);
	}

	inline const_iterator cend() noexcept {
		return const_iterator(_Elems._Last, size());
	}

public:
	inline size_type size() const noexcept {
		return static_cast<size_type>(_Elems._Last - _Elems._First);
	}

	inline size_type capacity() const noexcept {
		return static_cast<size_type>(_Elems._End - _Elems._First);
	}

	inline bool empty() const noexcept {
	return _Elems._First == _Elems._Last;
	}

	inline value_type front() const noexcept {
		return *_Elems._First;
	}

	inline value_type back() const noexcept {
		return *(_Elems._Last - 1);
	}

	inline void push_back(const value_type& _Val) {
		if (_Elems._Last == _Elems._End) {
			size_type _Capacity = _New_capacity();
			_Alloc(_Capacity);
		}

		_Emplace_back(_Val);
	}

    inline void pop_back() {
        if(_Elems._Last != _Elems._First) {
            --_Elems._Last;
            _Elems._Last->~_iTy();
        }
    }

    inline void reserve(size_type _Capacity) noexcept {
        _Alloc(_Capacity + capacity());
    }

private:
	inline void _Alloc(size_type _Capacity) noexcept {
		size_type _Size = size();
		pointer _Myfirst = new value_type[_Capacity];

		if (_Elems._First != nullptr) {
			for (size_type i = 0; i < _Size; ++i) {
				_Myfirst[i] = _Elems._First[i];
			}

			delete[] _Elems._First;
		}

		_Elems._First = _Myfirst;
		_Elems._Last  = _Myfirst + _Size;
		_Elems._End	  = _Myfirst + _Capacity;
	}

	inline void _Dealloc() noexcept {
		delete[] _Elems._First;
		_Elems._First = nullptr;
		_Elems._Last  = nullptr;
		_Elems._End   = nullptr;
	}

	inline void _Emplace_back(const value_type& _Val) {
		new (_Elems._Last) value_type(_Val);
		++_Elems._Last;
	}

	inline size_type _New_capacity() const {
		size_type _Current = static_cast<size_type>(_Elems._End - _Elems._First);
		size_type _New = _Current > 0 ? _Current + (_Current + 1) / 2 : 1;
		return _New;
	}

	vector_container<_iTy> _Elems;
};
_IRIS_END
#endif // _IVECTOR_