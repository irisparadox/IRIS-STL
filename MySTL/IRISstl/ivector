#ifndef _IVECTOR_
#define _IVECTOR
#include <imacros>
#include <imemory>
#include <iexceptions>

_IRIS_BEGIN
template <class _iTy>
class _iVector_const_iterator {
public:
	using value_type	  = _iTy;
	using const_pointer   = const _iTy*;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;
	using offset_type	  = ioffset_t;

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator() noexcept : _Ptr(), _Idx(0) {}
	_IRIS_CXX17_CONSTEXPR explicit _iVector_const_iterator(const_pointer _Pvec, offset_type _Off = 0) noexcept : _Ptr(_Pvec), _Idx(_Off) {}

public:
	_IRIS_CXX17_CONSTEXPR const_reference operator*() _IRIS_CONSEXCEPT {
		return *operator->();
	}

	_IRIS_CXX17_CONSTEXPR const_pointer operator->() _IRIS_CONSEXCEPT {
		return _Ptr + _Idx;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator& operator++() noexcept {
		++_Idx;
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator operator++(int) noexcept {
		_iVector_const_iterator _Copy = *this;
		++*this;
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator& operator--() noexcept {
		--_Idx;
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator operator--(int) noexcept {
		_iVector_const_iterator _Copy = *this;
		--*this;
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR bool operator==(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx == _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR bool operator!=(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx != _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR bool operator<(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx < _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR bool operator>(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx > _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR bool operator<=(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx <= _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR bool operator>=(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx >= _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator operator+(const offset_type _Off) _IRIS_CONSEXCEPT {
		_iVector_const_iterator _Copy = *this;
		_Copy._Idx += _Off;
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR offset_type operator+(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx + _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator& operator+=(const offset_type _Off) noexcept {
		_Idx += static_cast<size_type>(_Off);
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator operator-(const offset_type _Off) _IRIS_CONSEXCEPT {
		_iVector_const_iterator _Copy = *this;
		_Copy._Idx -= _Off;
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR offset_type operator-(const _iVector_const_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Idx - _Right._Idx;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_const_iterator& operator-=(const offset_type _Off) noexcept {
		_Idx -= static_cast<size_type>(_Off);
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR const_reference operator[](const offset_type _Off) _IRIS_CONSEXCEPT {
		return *(*this + _Off);
	}

private:
	[[noreturn]] static void iiterator_ran() {
		throw IRIS::not_in_range("Cannot increment iterator past end");
	}

	[[noreturn]] static void iiterator_zer() {
		throw IRIS::not_in_range("Cannot decrement iterator before begin");
	}

private:
	const_pointer _Ptr;
	offset_type _Idx;
};

template<class _iTy>
class _iVector_iterator : public _iVector_const_iterator<_iTy> {
public:
	using _Baseit = _iVector_const_iterator<_iTy>;

	using value_type  = _iTy;
	using pointer     = _iTy*;
	using reference   = _iTy&;
	using size_type   = isize_t;
	using offset_type = ioffset_t;

	_IRIS_CXX17_CONSTEXPR _iVector_iterator() noexcept {}
	_IRIS_CXX17_CONSTEXPR explicit _iVector_iterator(pointer _Parr, offset_type _Off = 0) noexcept : _Baseit(_Parr, _Off) {}

public:
	_IRIS_CXX17_CONSTEXPR reference operator*() _IRIS_CONSEXCEPT {
		return const_cast<reference>(_Baseit::operator*());
	}

	_IRIS_CXX17_CONSTEXPR reference operator->() _IRIS_CONSEXCEPT {
		return const_cast<reference>(_Baseit::operator->());
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator& operator++() noexcept {
		_Baseit::operator++();
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator operator++(int) noexcept {
		_iVector_iterator _Copy = *this;
		_Baseit::operator++();
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator& operator--() noexcept {
		_Baseit::operator--();
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator operator--(int) noexcept {
		_iVector_iterator _Copy = *this;
		_Baseit::operator--();
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR bool operator<(const _iVector_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Baseit::operator<(_Right);
	}

	_IRIS_CXX17_CONSTEXPR bool operator>(const _iVector_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Baseit::operator>(_Right);
	}

	_IRIS_CXX17_CONSTEXPR bool operator<=(const _iVector_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Baseit::operator<=(_Right);
	}

	_IRIS_CXX17_CONSTEXPR bool operator>=(const _iVector_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Baseit::operator>=(_Right);
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator operator+(const offset_type _Off) _IRIS_CONSEXCEPT {
		_iVector_iterator _Copy = *this;
		_Copy += _Off;
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR offset_type operator+(const _iVector_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Baseit::operator+(_Right);
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator& operator+=(const offset_type _Off) noexcept {
		_Baseit::operator+=(_Off);
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator operator-(const offset_type _Off) _IRIS_CONSEXCEPT {
		_iVector_iterator _Copy = *this;
		_Copy -= _Off;
		return _Copy;
	}

	_IRIS_CXX17_CONSTEXPR offset_type operator-(const _iVector_iterator& _Right) _IRIS_CONSEXCEPT {
		return _Baseit::operator-(_Right);
	}

	_IRIS_CXX17_CONSTEXPR _iVector_iterator& operator-=(const offset_type _Off) noexcept {
		_Baseit::operator-=(_Off);
		return *this;
	}

	_IRIS_CXX17_CONSTEXPR reference operator[](const offset_type _Off) _IRIS_CONSEXCEPT {
		return const_cast<reference>(_Baseit::operator[](_Off));
	}
};

template <class _iTy>
class vector_container {
public:
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference		  = _iTy&;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;

	_IRIS_CXX17_CONSTEXPR vector_container() noexcept : _First(), _Last(), _End() {}

	_IRIS_CXX17_CONSTEXPR vector_container(pointer _first, pointer _last, pointer _end) : _First(_first), _Last(_last), _End(_end) {}

	pointer _First;
	pointer _Last;
	pointer _End;
};

template <class _iTy>
class vector {
public:
	using value_type	  = _iTy;
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference       = _iTy&;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;
	using offset_type	  = ioffset_t;

	using const_iterator = _iVector_const_iterator<_iTy>;
	using iterator		 = _iVector_iterator<_iTy>;

	_IRIS_CXX17_CONSTEXPR vector() : _Elems() {}

	template <class... _iTy>
	_IRIS_CXX17_CONSTEXPR vector(_iTy&&... _Vec) : _Elems() {
		_initialize_with_variadic(_IRIS forward<_iTy>(_Vec)...);
	}

	_IRIS_CXX17_CONSTEXPR ~vector() {
		_Dealloc();
	}

public:
	_IRIS_CXX17_CONSTEXPR iterator begin() noexcept {
		return iterator(_Elems._First, 0);
	}

	_IRIS_CXX17_CONSTEXPR iterator end() noexcept {
		return iterator(_Elems._Last, size());
	}

	_IRIS_CXX17_CONSTEXPR const_iterator cbegin() noexcept {
		return const_iterator(_Elems._First, 0);
	}

	_IRIS_CXX17_CONSTEXPR const_iterator cend() noexcept {
		return const_iterator(_Elems._Last, size());
	}

public:
	_IRIS_CXX17_CONSTEXPR size_type size() _IRIS_CONSEXCEPT {
		return static_cast<size_type>(_Elems._Last - _Elems._First);
	}

	_IRIS_CXX17_CONSTEXPR size_type capacity() _IRIS_CONSEXCEPT {
		return static_cast<size_type>(_Elems._End - _Elems._First);
	}

	_IRIS_CXX17_CONSTEXPR bool empty() _IRIS_CONSEXCEPT {
	return _Elems._First == _Elems._Last;
	}

	_IRIS_CXX17_CONSTEXPR value_type front() const {
		if (empty()) empty_vector();
		return *_Elems._First;
	}

	_IRIS_CXX17_CONSTEXPR value_type back() const {
		if (empty()) empty_vector();
		return *(_Elems._Last - 1);
	}

	_IRIS_CXX17_CONSTEXPR pointer data() noexcept {
		return _Elems._First;
	}

	_IRIS_CXX17_CONSTEXPR const_pointer data() _IRIS_CONSEXCEPT {
		return _Elems._First;
	}

	_IRIS_CXX17_CONSTEXPR reference at(offset_type _Pos) {
		if (_Pos < 0 || _Pos >= size()) i_ran();
		return *(_Elems._First + _Pos);
	}

	constexpr const_reference at(offset_type _Pos) const {
		if (_Pos < 0 || _Pos >= size()) i_ran();
		return *(_Elems._First + _Pos);
	}

	_IRIS_CXX17_CONSTEXPR void push_back(const value_type& _Val) {
		if (_Elems._Last == _Elems._End) {
			size_type _Capacity = _New_capacity();
			_Alloc(_Capacity);
		}

		_Emplace_back(_Val);
	}

    _IRIS_CXX17_CONSTEXPR void pop_back() {
        if(_Elems._Last != _Elems._First) {
            --_Elems._Last;
            _Elems._Last->~_iTy();
        }
    }

    _IRIS_CXX17_CONSTEXPR void reserve(size_type _Capacity) noexcept {
        _Alloc(_Capacity + capacity());
    }

	_IRIS_CXX17_CONSTEXPR void clear() noexcept {
		if (_Elems._First != nullptr) {
			for (pointer _Ptr = _Elems._First; _Ptr != _Elems._Last; ++_Ptr) {
				_Ptr->~_iTy();
			}

			_Elems._Last = _Elems._First;
		}
	}

public:
	_IRIS_CXX17_CONSTEXPR iterator insert(const_iterator _Idx, const value_type& _Val) {
		if (_Idx < begin() || _Idx > end()) invalid_iterator();
		
		offset_type _Pos = static_cast<offset_type>(_Idx - begin());

		if (_Elems._Last == _Elems._End) {
			size_type _cap = _New_capacity();
			_Alloc(_cap);
		}

		size_type _Size = size();

		for (offset_type i = _Size; i > _Pos; --i) {
			*(_Elems._First + i) = *(_Elems._First + (i - 1));
		}

		new (_Elems._First + _Pos) value_type(_Val);

		++_Elems._Last;

		return iterator(_Elems._First + _Pos);
	}

	_IRIS_CXX17_CONSTEXPR iterator erase(const_iterator _Idx) {
		if (_Idx < begin() || _Idx > end()) invalid_iterator();
		if (empty()) empty_vector();

		offset_type _Pos = static_cast<offset_type>(_Idx - begin());
		size_type _Size = size();

		for (size_type i = _Pos + 1; i < _Size; ++i) {
			*(_Elems._First + (i - 1)) = *(_Elems._First + i);
		}
		--_Elems._Last;
		_Elems._Last->~_iTy();
		return iterator(_Elems._First + _Pos);
	}

public:
	_IRIS_CXX17_CONSTEXPR reference operator[](size_type _Pos) {
		if (_Pos < 0 || _Pos >= size()) i_ran();

		return *(_Elems._First + _Pos);
	}

	_IRIS_CXX17_CONSTEXPR const_reference operator[](size_type _Pos) const {
		if (_Pos < 0 || _Pos >= size()) i_ran();

		return *(_Elems._First + _Pos);
	}

	constexpr bool operator==(const vector& _Right) const {
		if (size() != _Right.size()) return false;

		auto& _RData = _Right._Elems;
		pointer _Ptrl  = _Elems._First;
		pointer _Ptrr = _RData._First;
		while (_Ptrl != _Elems._Last && _Ptrr != _RData._Last) {
			if (*_Ptrl != *_Ptrr) return false;
			++_Ptrl;
			++_Ptrr;
		}

		return true;
	}

private:
	_IRIS_CXX17_CONSTEXPR void _Alloc(size_type _Capacity) noexcept {
		size_type _Size = size();
		pointer _Myfirst = new value_type[_Capacity];

		if (_Elems._First != nullptr) {
			for (size_type i = 0; i < _Size; ++i) {
				*(_Myfirst + i) = *(_Elems._First + i);
			}

			delete[] _Elems._First;
		}

		_Elems._First = _Myfirst;
		_Elems._Last  = _Myfirst + _Size;
		_Elems._End	  = _Myfirst + _Capacity;
	}

	_IRIS_CXX17_CONSTEXPR void _Dealloc() noexcept {
		delete[] _Elems._First;
		_Elems._First = nullptr;
		_Elems._Last  = nullptr;
		_Elems._End   = nullptr;
	}

	template <class... _iTy>
	_IRIS_CXX17_CONSTEXPR void _initialize_with_variadic(_iTy&&... _Vec) {
		size_type _Size = sizeof...(_Vec);
		_Alloc(_Size);
		((*_Elems._Last++ = _IRIS forward<_iTy>(_Vec)), ...);
	}

	_IRIS_CXX17_CONSTEXPR void _Emplace_back(const value_type& _Val) {
		new (_Elems._Last) value_type(_Val);
		++_Elems._Last;
	}

	_IRIS_CXX17_CONSTEXPR size_type _New_capacity() const {
		size_type _Current = static_cast<size_type>(_Elems._End - _Elems._First);
		size_type _New = _Current > 0 ? _Current + (_Current + 1) / 2 : 1;
		return _New;
	}

	vector_container<_iTy> _Elems;

private:
	[[noreturn]] static void i_ran() {
		throw IRIS::not_in_range("Specified index is out of range");
	}

	[[noreturn]] static void invalid_iterator() {
		throw IRIS::not_in_range("Specified iterator is out of range");
	}

	[[noreturn]] static void empty_vector() {
		throw IRIS::empty_container("Vector is empty");
	}
};
_IRIS_END
#endif // _IVECTOR_