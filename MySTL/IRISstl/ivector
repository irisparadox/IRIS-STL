#ifndef _IVECTOR_
#define _IVECTOR
#include <imacros>
#include <iexceptions>

_IRIS_BEGIN
template <class _iTy>
class _iVector_const_iterator {
public:
	using value_type	  = _iTy;
	using const_pointer   = const _iTy*;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;
	using offset_type	  = ioffset_t;

	inline _iVector_const_iterator() noexcept : _Ptr(), _Idx(0) {}
	inline explicit _iVector_const_iterator(const_pointer _Pvec, offset_type _Off = 0) noexcept : _Ptr(_Pvec), _Idx(_Off) {}

public:
	inline const_reference operator*() const noexcept {
		return *operator->();
	}

	inline const_pointer operator->() const noexcept {
		return _Ptr + _Idx;
	}

	inline _iVector_const_iterator& operator++() noexcept {
		++_Idx;
		return *this;
	}

	inline _iVector_const_iterator operator++(int) noexcept {
		_iVector_const_iterator _Copy = *this;
		++*this;
		return _Copy;
	}

	inline _iVector_const_iterator& operator--() noexcept {
		--_Idx;
		return *this;
	}

	inline _iVector_const_iterator operator--(int) noexcept {
		_iVector_const_iterator _Copy = *this;
		--*this;
		return _Copy;
	}

	inline bool operator==(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx == _Right._Idx;
	}

	inline bool operator!=(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx != _Right._Idx;
	}

	inline bool operator<(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx < _Right._Idx;
	}

	inline bool operator>(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx > _Right._Idx;
	}

	inline bool operator<=(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx <= _Right._Idx;
	}

	inline bool operator>=(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx >= _Right._Idx;
	}

	inline _iVector_const_iterator operator+(const offset_type _Off) const noexcept {
		_iVector_const_iterator _Copy = *this;
		_Copy += _Off;
		return _Copy;
	}

	inline offset_type operator+(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx + _Right._Idx;
	}

	inline _iVector_const_iterator operator-(const offset_type _Off) const noexcept {
		_iVector_const_iterator _Copy = *this;
		_Copy -= _Off;
		return _Copy;
	}

	inline offset_type operator-(const _iVector_const_iterator& _Right) const noexcept {
		return _Idx - _Right._Idx;
	}

	inline const_reference operator[](const offset_type _Off) const noexcept {
		return *(*this + _Off);
	}

private:
	[[noreturn]] static void iiterator_ran() {
		throw IRIS::not_in_range("Cannot increment iterator past end");
	}

	[[noreturn]] static void iiterator_zer() {
		throw IRIS::not_in_range("Cannot decrement iterator before begin");
	}

private:
	const_pointer _Ptr;
	offset_type _Idx;
};

template<class _iTy>
class _iVector_iterator : public _iVector_const_iterator<_iTy> {
public:
	using _Baseit = _iVector_const_iterator<_iTy>;

	using value_type  = _iTy;
	using pointer     = _iTy*;
	using reference   = _iTy&;
	using size_type   = isize_t;
	using offset_type = ioffset_t;

	inline _iVector_iterator() noexcept {}
	inline explicit _iVector_iterator(pointer _Parr, offset_type _Off = 0) noexcept : _Baseit(_Parr, _Off) {}

public:
	inline reference operator*() const noexcept {
		return const_cast<reference>(_Baseit::operator*());
	}

	inline reference operator->() const noexcept {
		return const_cast<reference>(_Baseit::operator->());
	}

	inline _iVector_iterator& operator++() noexcept {
		_Baseit::operator++();
		return *this;
	}

	inline _iVector_iterator operator++(int) noexcept {
		_iVector_iterator _Copy = *this;
		_Baseit::operator++();
		return _Copy;
	}

	inline _iVector_iterator& operator--() noexcept {
		_Baseit::operator--();
		return *this;
	}

	inline _iVector_iterator operator--(int) noexcept {
		_iVector_iterator _Copy = *this;
		_Baseit::operator--();
		return _Copy;
	}

	inline bool operator<(const _iVector_iterator& _Right) const noexcept {
		return _Baseit::operator<(_Right);
	}

	inline bool operator>(const _iVector_iterator& _Right) const noexcept {
		return _Baseit::operator>(_Right);
	}

	inline bool operator<=(const _iVector_iterator& _Right) const noexcept {
		return _Baseit::operator<=(_Right);
	}

	inline bool operator>=(const _iVector_iterator& _Right) const noexcept {
		return _Baseit::operator>=(_Right);
	}

	inline _iVector_iterator operator+(const offset_type _Off) const noexcept {
		_iVector_iterator _Copy = *this;
		_Copy += _Off;
		return _Copy;
	}

	inline offset_type operator+(const _iVector_iterator& _Right) const noexcept {
		return _Baseit::operator+(_Right);
	}

	inline _iVector_iterator operator-(const offset_type _Off) const noexcept {
		_iVector_iterator _Copy = *this;
		_Copy -= _Off;
		return _Copy;
	}

	inline offset_type operator-(const _iVector_iterator& _Right) const noexcept {
		return _Baseit::operator-(_Right);
	}

	inline reference operator[](const offset_type _Off) const noexcept {
		return const_cast<reference>(_Baseit::operator[](_Off));
	}
};

template <class _iTy>
class vector_container {
public:
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference		  = _iTy&;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;

	inline vector_container() noexcept : _First(), _Last(), _End() {}

	inline vector_container(pointer _first, pointer _last, pointer _end) : _First(_first), _Last(_last), _End(_end) {}

	pointer _First;
	pointer _Last;
	pointer _End;
};

template <class _iTy>
class ivector {
public:
	using value_type	  = _iTy;
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference       = _iTy&;
	using const_reference = const _iTy&;
	using size_type		  = isize_t;
	using offset_type	  = ioffset_t;

	using const_iterator = _iVector_const_iterator<_iTy>;
	using iterator		 = _iVector_iterator<_iTy>;

	inline ivector() : _Elems() {}

	template <class... _iTy>
	inline ivector(_iTy&&... _Vec) : _Elems() {
		_initialize_with_variadic(static_cast<_iTy&&>(_Vec)...);
	}

	inline ~ivector() {
		_Dealloc();
	}

public:
	inline iterator begin() noexcept {
		return iterator(_Elems._First, 0);
	}

	inline iterator end() noexcept {
		return iterator(_Elems._Last, size());
	}

	inline const_iterator cbegin() noexcept {
		return const_iterator(_Elems._First, 0);
	}

	inline const_iterator cend() noexcept {
		return const_iterator(_Elems._Last, size());
	}

public:
	inline size_type size() const noexcept {
		return static_cast<size_type>(_Elems._Last - _Elems._First);
	}

	inline size_type capacity() const noexcept {
		return static_cast<size_type>(_Elems._End - _Elems._First);
	}

	inline bool empty() const noexcept {
	return _Elems._First == _Elems._Last;
	}

	inline value_type front() const noexcept {
		if (size() <= 0) empty_vector();
		return *_Elems._First;
	}

	inline value_type back() const noexcept {
		if (size() <= 0) empty_vector();
		return *(_Elems._Last - 1);
	}

	inline void push_back(const value_type& _Val) {
		if (_Elems._Last == _Elems._End) {
			size_type _Capacity = _New_capacity();
			_Alloc(_Capacity);
		}

		_Emplace_back(_Val);
	}

    inline void pop_back() {
        if(_Elems._Last != _Elems._First) {
            --_Elems._Last;
            _Elems._Last->~_iTy();
        }
    }

    inline void reserve(size_type _Capacity) noexcept {
        _Alloc(_Capacity + capacity());
    }

	inline void clear() noexcept {
		if (_Elems._First != nullptr) {
			for (pointer _Ptr = _Elems._First; _Ptr != _Elems._Last; ++_Ptr) {
				_Ptr->~_iTy();
			}

			_Elems._Last = _Elems._First;
		}
	}

public:
	inline iterator insert(iterator _Idx, const value_type& _Val) {
		if (_Idx < begin() || _Idx > end()) invalid_iterator();
		
		offset_type _Pos = static_cast<offset_type>(_Idx - begin());

		if (_Elems._Last == _Elems._End) {
			size_type _cap = _New_capacity();
			_Alloc(_cap);
		}

		for (offset_type i = size(); i > _Pos; --i) {
			*(_Elems._First + i) = *(_Elems._First + (i - 1));
		}

		new (_Elems._First + _Pos) value_type(_Val);

		++_Elems._Last;

		return iterator(_Elems._First + _Pos);
	}

public:
	inline reference operator[](size_type _Pos) {
		if (_Pos < 0 || _Pos >= size()) i_ran();

		return *(_Elems._First + _Pos);
	}

	inline const_reference operator[](size_type _Pos) const {
		if (_Pos < 0 || _Pos >= size()) i_ran();

		return *(_Elems._First + _Pos);
	}

private:
	inline void _Alloc(size_type _Capacity) noexcept {
		size_type _Size = size();
		pointer _Myfirst = new value_type[_Capacity];

		if (_Elems._First != nullptr) {
			for (offset_type i = 0; i < _Size; ++i) {
				*(_Myfirst + i) = *(_Elems._First + i);
			}

			delete[] _Elems._First;
		}

		_Elems._First = _Myfirst;
		_Elems._Last  = _Myfirst + _Size;
		_Elems._End	  = _Myfirst + _Capacity;
	}

	inline void _Dealloc() noexcept {
		delete[] _Elems._First;
		_Elems._First = nullptr;
		_Elems._Last  = nullptr;
		_Elems._End   = nullptr;
	}

	template <class... _iTy>
	inline void _initialize_with_variadic(_iTy&&... _Vec) {
		size_type _Size = sizeof...(_Vec);
		_Alloc(_Size);
		((*_Elems._Last++ = static_cast<_iTy&&>(_Vec)), ...);
	}

	inline void _Emplace_back(const value_type& _Val) {
		new (_Elems._Last) value_type(_Val);
		++_Elems._Last;
	}

	inline size_type _New_capacity() const {
		size_type _Current = static_cast<size_type>(_Elems._End - _Elems._First);
		size_type _New = _Current > 0 ? _Current + (_Current + 1) / 2 : 1;
		return _New;
	}

	vector_container<_iTy> _Elems;

private:
	[[noreturn]] static void i_ran() {
		throw IRIS::not_in_range("Specified index is out of range");
	}

	[[noreturn]] static void invalid_iterator() {
		throw IRIS::not_in_range("Specified iterator is out of range");
	}

	[[noreturn]] static void empty_vector() {
		throw IRIS::empty_container("Vector is empty");
	}
};
_IRIS_END
#endif // _IVECTOR_