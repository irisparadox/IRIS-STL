#ifndef _IMATH_
#define _IMATH_
#include <imacros>
#include <iexceptions>

_IRIS_BEGIN
long double abs(const long double& _Num) {
	return (_Num < 0) ? -_Num : _Num;
}

long double sqrt(const long double& _Num) {
	if (_Num < 0) throw _IRIS neg_sqrt("Negative number provided on sqrt");
	if (_Num == 0 || _Num == 1) return _Num;

	long double _epsilon = 0.0000000000000001;
	long double _X = _Num;

	while (true) {
		long double _Next_X = 0.5 * (_X + _Num / _X);
		if (abs(_Next_X - _X) < _epsilon) {
			break;
		}
		_X = _Next_X;
	}

	return _X;
}

float atan(float _X) {
	static const uint32_t sign_mask = 0x80000000;
	static const float b = 0.596227f;

	// Extract the sign bit
	uint32_t ux_s = sign_mask & (uint32_t&)_X;

	// Calculate the arctangent in the first quadrant
	float bx_a = (float)abs(b * _X);
	float num = bx_a + _X * _X;
	float atan_1q = num / (1.f + bx_a + num);

	// Restore the sign bit
	uint32_t atan_2q = ux_s | (uint32_t&)atan_1q;
	return (float&)atan_2q;
}

float atan2(float _Y, float _X) {
	static const uint32_t sign_mask = 0x80000000;
	static const float b = 0.596227f;

	// Extract the sign bits
	uint32_t ux_s = sign_mask & (uint32_t&)_X;
	uint32_t uy_s = sign_mask & (uint32_t&)_Y;

	// Determine the quadrant offset
	float q = (float)((~ux_s & uy_s) >> 29 | ux_s >> 30);

	// Calculate the arctangent in the first quadrant
	float bxy_a = (float)abs(b * _X * _Y);
	float num = bxy_a + _Y * _Y;
	float atan_1q = num / (_X * _X + bxy_a + num);

	// Translate it to the proper quadrant
	uint32_t uatan_2q = (ux_s ^ uy_s) | (uint32_t&)atan_1q;
	return q + (float&)uatan_2q;
}
_IRIS_END
#endif // _IMATH_
