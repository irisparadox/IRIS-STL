#ifndef _IARRAY_
#define _IARRAY_
#include <imacros>
#include <iexceptions>

_IRIS_BEGIN
template <class _iTy, isize_t _Size>
class iarray {
public:
	using value_type	   = _iTy;
	using ireference	   = _iTy&;
	using const_ireference = const _iTy&;
	using ipointer		   = _iTy*;
	using const_ipointer   = const _iTy*;
	using size_type		   = isize_t;

public:
	inline void swap(size_type _First, size_type _Second) {
		if (_Pos < 0 || _Pos >= _Size) i_ran();

		value_type temp = _Elems[_First];
		_Elems[_First] = _Elems[_Second];
		_Elems[_Second] = temp;
	}

	constexpr size_type size() const noexcept {
		return _Size;
	}

	constexpr bool empty() const noexcept {
		return false;
	}

	inline ireference at(size_type _Pos) {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size) i_ran();

		return _Elems[_Pos];
	}

	constexpr const_ireference at(size_type _Pos) const {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size) i_ran();

		return _Elems[_Pos];
	}

	inline ireference operator[](size_type _Pos) {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size) i_ran();

		return _Elems[_Pos];
	}

	constexpr const_ireference operator[](size_type _Pos) const {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size) i_ran();

		return _Elems[_Pos];
	}

	inline ireference front() noexcept {
		return _Elems[0];
	}

	constexpr const_ireference front() const noexcept {
		return _Elems[0];
	}

	inline ireference back() noexcept {
		return _Elems[_Size - 1];
	}

	constexpr const_ireference back() const noexcept {
		return _Elems[_Size - 1];
	}

	inline ipointer data() noexcept {
		return _Elems;
	}

	constexpr const_ipointer data() const noexcept {
		return _Elems;
	}

	_iTy _Elems[_Size];
private:
	[[noreturn]] static void i_ran() {
		throw IRIS::not_in_range("Specified index is out of range");
	}
};
_IRIS_END
#endif // _IARRAY_
