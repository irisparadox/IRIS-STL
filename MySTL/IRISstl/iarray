#ifndef _IARRAY_
#define _IARRAY_
#include <imacros>

_IRIS_BEGIN
template <typename T, isize_t _Size>
class iarray {
public:
	using ireference	   = T&;
	using const_ireference = const T&;
	using ipointer		   = T*;
	using const_ipointer   = const T*;
	using size_type		   = isize_t;

public:
	constexpr size_type size() const noexcept {
		return _Size;
	}

	constexpr bool empty() const noexcept {
		return false;
	}

	inline ireference at(size_type _Pos) {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size)
			throw IRIS::not_in_range("Specified index is out of range");

		return _Elems[_Pos];
	}

	constexpr const_ireference at(size_type _Pos) const {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size)
			throw IRIS::not_in_range("Specified index is out of range");

		return _Elems[_Pos];
	}

	inline ireference operator[](size_type _Pos) {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size)
			throw IRIS::not_in_range("Specified index is out of range");

		return _Elems[_Pos];
	}

	constexpr const_ireference operator[](size_type _Pos) const {
		static_assert(_Size > 0, "Evaluating empty array");

		if (_Pos < 0 || _Pos >= _Size)
			throw IRIS::not_in_range("Specified index is out of range");

		return _Elems[_Pos];
	}

	inline ireference front() noexcept {
		return _Elems[0];
	}

	constexpr const_ireference front() const noexcept {
		return _Elems[0];
	}

	inline ireference back() noexcept {
		return _Elems[_Size - 1];
	}

	constexpr const_ireference back() const noexcept {
		return _Elems[_Size - 1];
	}

	inline ipointer data() noexcept {
		return _Elems;
	}

	constexpr const_ipointer data() const noexcept {
		return _Elems;
	}

private:
	T _Elems[_Size];

};
_IRIS_END
#endif // _IARRAY_
