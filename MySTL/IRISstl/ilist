#ifndef _ILIST_
#define _ILIST_
#include <imacros>
#include <imemory>
#include <iexceptions>

_IRIS_BEGIN
template <class _iTy>
struct _Node {
	using value_type = _iTy;
	using _Nodeptr	 = _Node*;
	_Nodeptr _Next;
	_Nodeptr _Prev;
	value_type _Val;

	_Node()						   = default;
	_Node(const _Node&)			   = delete;
	_Node& operator=(const _Node&) = delete;

	static _Nodeptr _Reheadnode() {
		// buy a block of heap and then point towards head
		const auto _Head = _Allocate<_Node>(1);
		_Construct_placed(_Head->_Next, _Head);
		_Construct_placed(_Head->_Prev, _Head);
		return _Head;
	}

	static void _Freenode0(_Nodeptr _Ptr) noexcept {
		_Destroy_placed(_Ptr->_Next);
		_Destroy_placed(_Ptr->_Prev);
		_Deallocate<_Node>(_Ptr, 1);
	}

	static void _Freenode(_Nodeptr _Ptr) noexcept {
		// destroy node and then free children
		_Destroy<_iTy>(_Ptr->_Val);
		_Freenode0(_Ptr);
	}

	static void _Free_non_head(_Nodeptr _Head) noexcept { // iterates through list and frees all nodes
		// disconnect head from list
		_Head->_Prev->_Next = nullptr;
		auto _PtrNode = _Head->_Next;
		for (_Nodeptr _PtrNext; _PtrNode; _PtrNode = _PtrNext) {
			_PtrNext = _PtrNode->_Next;
			_Freenode(_PtrNode);
		}
	}
};

template <class _iTy>
class list {
public:
	using value_type	  = _iTy;
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference		  = _iTy&;
	using const_reference = const _iTy&;

	using _Node = _Node<value_type>;
	using _Nodeptr = typename _Node::_Nodeptr;

	list() noexcept : _Size(0) {
		_Head = _Node::_Reheadnode();
	}

	list(const list& _Other) {
		// TODO ITERATORS
		/*for (auto& _Thenode : _Other) {
			push_back(_Thenode);
		}
		*/
	}

	~list() noexcept {
		_Free();
		_Size = 0;
	}

public:
	_IRIS_CXX17_CONSTEXPR size_type size() _IRIS_CONSEXCEPT {
		return _Size;
	}

	_IRIS_CXX17_CONSTEXPR bool empty() _IRIS_CONSEXCEPT {
		return _Size == 0;
	}

	_IRIS_CXX17_CONSTEXPR value_type front() const {
#if __EXCEPTIONS__
		if (empty())
#endif
		return _Head->_Next->_Val;
	}

	_IRIS_CXX17_CONSTEXPR value_type back() const {
#if __EXCEPTIONS__
		if (empty())
#endif
		return _Head->_Prev->_Val;
	}

	void push_front(const value_type& _Val) {
		_Nodeptr _newnode = _Allocate<_Node>(1);

		_Construct_placed(_newnode->_Val, _Val);
		_Emplace_node_at_front(_newnode);
		++_Size;
	}

	void push_front(value_type&& _Val) {
		_Nodeptr _newnode = _Allocate<_Node>(1);

		_Construct_placed(_newnode->_Val, _IRIS move(_Val));
		_Emplace_node_at_front(_newnode);
		++_Size;
	}

	void push_back(const value_type& _Val) {
		_Nodeptr _newnode = _Allocate<_Node>(1);

		_Construct_placed(_newnode->_Val, _Val);
		_Emplace_node_at_back(_newnode);
		++_Size;
	}

	void push_back(value_type&& _Val) {
		_Nodeptr _newnode = _Allocate<_Node>(1);

		_Construct_placed(_newnode->_Val, _IRIS move(_Val));
		_Emplace_node_at_back(_newnode);
		++_Size;
	}

public:
	void clear() noexcept {
		_Node::_Free_non_head(_Head);
		_Head->_Next = _Head;
		_Head->_Prev = _Head;
		_Size = 0;
	}

private:
	void _Free() noexcept {
		if(!empty()) _Node::_Free_non_head(_Head);
		_Node::_Freenode0(_Head);
	}

private:
	_IRIS_CXX17_CONSTEXPR void _Emplace_empty(_Nodeptr _Ptr) {
		_Head->_Next = _Ptr;
		_Head->_Prev = _Ptr;
		_Ptr->_Next = _Head;
		_Ptr->_Prev = _Head;
	}

	void _Emplace_node_at_front(_Nodeptr _Ptr) {
		if (empty()) _Emplace_empty(_Ptr);
		else {
			_Ptr->_Prev = _Head;
			_Ptr->_Next = _Head->_Next;
			_Head->_Next->_Prev = _Ptr;
			_Head->_Next = _Ptr;
		}
	}

	void _Emplace_node_at_back(_Nodeptr _Ptr) {
		if (empty()) _Emplace_empty(_Ptr);
		else {
			_Ptr->_Prev			= _Head->_Prev;
			_Ptr->_Next			= _Head;
			_Head->_Prev->_Next = _Ptr;
			_Head->_Prev		= _Ptr;
		}
	}

private:
	_Nodeptr _Head; // pointer to head node
	size_type _Size;
};
_IRIS_END
#endif // _ILIST_
