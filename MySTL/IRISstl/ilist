#ifndef _ILIST_
#define _ILIST_
#include <imacros>
#include <imemory>
#include <iexceptions>

_IRIS_BEGIN
template <class _iTy>
struct _Node {
	using value_type = _iTy;
	using _Nodeptr	 = _Node*;
	_Nodeptr _Next;
	_Nodeptr _Prev;
	value_type _Val;

	_Node()						   = default;
	_Node(const _Node&)			   = delete;
	_Node& operator=(const _Node&) = delete;

	static _Nodeptr _Reheadnode() {
		const auto _Head = _Allocate<_Node>(1);
		_Construct_placed(_Head->_Next, _Head);
		_Construct_placed(_Head->_Prev, _Head);
		return _Head;
	}

	static void _Freenode0(_Nodeptr _Ptr) noexcept {
		_Destroy_placed(_Ptr->_Next);
		_Destroy_placed(_Ptr->_Prev);
		_Deallocate<_Node>(_Ptr, 1);
	}

	static void _Freenode(_Nodeptr _Ptr) noexcept {
		_Destroy<_Node>(_Ptr);
		_Freenode0(_Ptr);
	}
};

template <class _iTy>
class ilist {
public:
	using value_type	  = _iTy;
	using pointer		  = _iTy*;
	using const_pointer	  = const _iTy*;
	using reference		  = _iTy&;
	using const_reference = const _iTy&;
};
_IRIS_END
#endif // _ILIST_
